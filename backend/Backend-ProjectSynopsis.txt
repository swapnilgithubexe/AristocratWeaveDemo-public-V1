"***Project Synopsis***
"Day 1":
"task 1":
started with creating a folder and creating the backend and frontend folders, installed express, mongoose, dotenv packages.
Created multiple folders for starters like app.js and server.js, the entry point is set which is server.js
There are two scripts for dev mode and prod mode
start:node backend/server.js,
dev:nodemon backend/server.js
Created multiple folders as mentioned below:
Routes
models
utils
controllers
config
middleware

"task 2":
created a server





"Day 2:"

"task 1"
In the create product function, I encountered an error while working with async await, if we dont use try and catch here and one required item got missed, it will go into an infinite loop, so tried try and catch but writing it all the time is not a good practice, for example
code: 
try {
    const product = await Product.create(req.body);
    res.status(201).json({ success: true, product })
  } catch (err) {
    res.status(500).json({
      success: false,
      message: err.message
    })
  }

handles the error if caught any, and we can use throw as well, but here we will create another error handling middleware which is catchAsyncError: which throws the error and wrapped the controller routes within it.

"task 2"

Used the concept of unhandledRejection event from error handling in nodejs

tested if the connection string of the database is hindered (context of UPR), and then created a rejection handler function on the process object.

"task 3"

study about cast error in context of DBs(MongoDB)
Data mismatch gives us a CAST error
I created a simple error handler 
if (err.name === "CastError") {
    const message = `Resource not found. Invalid path: ${err.path}`;
    err = new ErrorHandler(message, 400);
  }

"task 4"

learned about pagination, applying api features, queries of the url
created a apifeature Class that helps with constructing mongodb queries based on request parameters
then used that apifeature Class in the controller, the get all products function uses api feature to search that product

"task 5"

I learned while returning(this) the instance from the search method is a technique called method chaining from (oops), where we return this from all the methods and the search or any other method can be called on the same object in a single line of code like
new ApiFeature(Product.find, req.query).search().paginate(x)...

in the filter function itself created a querycopy object with shallow copy technique(spread op)
removed the keyword, page, limit fields from thequeryccopy just to have range of price and rating, converted the queryCopy into a string and
manipulated the gt, lt, gte, lte standalones with $gt, $lt, $gte,$lte.
and the final queryCopy becomes:
this.query.find({
  price: {
    $lt: 100,
    $gte: 50
  },
  rating: {
    $gte: 4
});

which is processed by mongoDB.

Then we created a pagination function which allows us to show only 5 elements at a timecurrent page is either taken from the query or default 1st
there is a formula for skip counting 
skip = (resultperpage which is 5 as default)*(currentpage - 1)
this.query = this.query.limit(resultperpage).skip(skip)
this sets the new query with the limit and the skip for the next query resolution - Tested on POSTMAN

"Day 3:"

Read about User Authentication

"task 1":

installed bcryptjs, jsonwebtoken, validator, nodemailer, cookie-parser, body-parser

Created two files - userController and userRoute
created a register route, which creates a new user in the database by passing all the required parameters, did the same thing for login as well where I matched the email and pass using if else statements

"task 2:"
password is being encrypted or hashed using bcrypt().hash method

when the password got matched or the registration was successful, we created a function which generates a token with the expiry date, and the token_key.

token is stored in cookies for safety and given to new users or users whose password got matched(used passwordCompare function).

"task 3:"

in the user controller file, created 2 apis for login and log out,  took email and password from the req.body and matched them in the database: like email from the database, and retreived the +password from the database although the select field is false, and then we compared the passwords and sent the response accordingly.

created the logout api as well and within a second the cookie is removed.

"task 4:"

created a auth.js file for all types of authentication apis like if the user is authenticated or not, and the role of the user, I got some help from the BackEnd-TA as well.
when the apis were created the tested with the admin routes such as creating a new product, updating and deleteing the product.
NOTE: Also learned how to create admin specific routes, for eg- we can use tokens to manipulate the user specific behaviors, like after log out if we remove the token from the cookie, then the unlogged user is not abled to perform some ops.


"Day 4:"

day 4:

"task 1:"
Learned about creating random token using crypto.randomBytes and how hashing works with sha256 algorithm.

the my TA taught me how to create a URL using the new token which remains active for 15 mins, My task was to handle the error part of this assignment, so firstly wrapped this whole function inside the catchAsyncError class, created a message for the mail recipient used try and catch blocks while calling the sendMail function

"task 2:"
made the mailer ready by adding the app password and 2 step verification, generated a token of random numbers and hashed, sent the reset password token combined in URL, tested the same by testing data.

at the same reset token url, we created a update password endpoint, in which, we checked the expiry of the token, and changed the password. - more than half of the code was written by my TA

"task 3:"

TA said the update pass is similar to delete and I should do it.
steps: tried to find the user by ID, the used the compare password func which was created earlier to match the hashed password,
if not matched, err is thrown.
if matched, two fields should be matched, newpassword-confimpassword
if correct user password will be changed and logged in immediately.

"task 4:"

created api endpoints for updating the user profile as well
created a new object of new field values, and if the user is authenticated the details were changed.

Created some admin routes for updating, deleting users and to get all users- used findOne, find(), findByIdAndUpdate/Delete after authentication.

"Note(V. Imp.)" - we should use req.params.id when its product related or admin trying to make changes, but req.user.id when authentication is required.

"Day 5:"

"Task 1:"
Created an api for creating reviews and give ratings for a product
1st. extracted the rating, reviews, productID from the req.body
created a new review object and checked 2 conditions if the product is available and if the user has already added any review.

if already exists the data is modified or else the review object is pushed to the review array

"Task 2:"

created an api endpoint to list all the list of queries for a product
created an api to delete a review from the product.review List
for both of them just create an instance of the product and after validation, just delete the review and reducing the review count.

"Task 3:"

created two files for order schema and order routes
created an api endpoint for creating a order, I used dummy data just to test.
created an api endpoint to get the order details for both user and admin(total orders made), and for admin there is a total amount variable to get the total amount of order
created an api endpoint to change the orderStatus, only for admin, tgere are certain conditions, if the status is already delivered and if not, plus we change the count of stock when the order gets delivered
then created a delete order endpoint.


video: 6:36:00







 





















"